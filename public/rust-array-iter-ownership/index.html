<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  
  
  

  <title>
    
    A little bit of Rust: Comparing Array Iteration vs. C++ and Borrow Checker Safety
    
</title>

  
  <link rel="stylesheet" href="https://www.shray.fyi/site.css">
  

  
  
</head>

<body class="hack dark main container">
  
    
        
  
  
    

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <nav class="breadcrumb">
            <a href="https://www.shray.fyi/">&larr; Back to Blog</a>
        </nav>
        <h1 itemprop="headline">A little bit of Rust: Comparing Array Iteration vs. C++ and Borrow Checker Safety</h1>
        <span class="muted">
    <svg class="icon i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>3 minute read</span>
    <svg class="icon i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2025-08-12
</span>
    </header>
    <div itemprop="articleBody">
      <p>The way that even simple algorithms are implemented in Rust vs. C++ or other languages is often a big departure, both in syntax and in what safe guards are enforced for getting it done.</p>
<p>I wanted to use a small but interesting problem to show how Rust, at compile time, provides more memory safety and avoids certain classes of issues that may be seen otherwise.</p>
<p>On one hand, the safe guards enforced by the borrow checker mean that compiled Rust code can make greater guarantees than other code, but especially for people using it for the first time, a lot of code that may seem totally innocous, or compile-able in another language, becomes a stream of compiler errors and headache with Rust. I definitely spent a lot of time initially just monkey-debugging around this, but over time have realized that the errors are actually almost always insightful and helpful when I actually take 30 seconds to read them.</p>
<h2 id="the-problem-first-missing-positive">The Problem: First Missing Positive</h2>
<p>Find the smallest positive integer that is not present in the array.</p>
<p><strong>Example:</strong></p>
<ul>
<li>Input: <code>[1, 2, 0]</code> → Output: <code>3</code></li>
<li>Input: <code>[3, 4, -1, 1]</code> → Output: <code>2</code></li>
<li>Input: <code>[7, 8, 9, 11, 12]</code> → Output: <code>1</code></li>
</ul>
<h2 id="c-solution-unrestricted-access">C++ Solution: Unrestricted Access</h2>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">class </span><span style="color:#ebcb8b;">Solution </span><span style="color:#eff1f5;">{
</span><span style="color:#b48ead;">public</span><span style="color:#eff1f5;">:
</span><span style="color:#eff1f5;">    </span><span style="color:#b48ead;">int </span><span style="color:#8fa1b3;">firstMissingPositive</span><span style="color:#eff1f5;">(vector&lt;</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;">&gt;</span><span>&amp; </span><span style="color:#bf616a;">nums</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> n </span><span>=</span><span style="color:#eff1f5;"> nums.</span><span style="color:#bf616a;">size</span><span style="color:#eff1f5;">();
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">bool</span><span style="color:#eff1f5;"> contains1 </span><span>= </span><span style="color:#d08770;">false</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// Replace negative numbers, zeros,
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// and numbers larger than n with 1s.
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// After this nums contains only positive numbers.
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> i </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">; i </span><span>&lt;</span><span style="color:#eff1f5;"> n; i</span><span>++</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">            </span><span style="color:#65737e;">// Check whether 1 is in the original array
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(nums[i] </span><span>== </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">                contains1 </span><span>= </span><span style="color:#d08770;">true</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            }
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(nums[i] </span><span>&lt;= </span><span style="color:#d08770;">0 </span><span>||</span><span style="color:#eff1f5;"> nums[i] </span><span>&gt;</span><span style="color:#eff1f5;"> n) {
</span><span style="color:#eff1f5;">                nums[i] </span><span>= </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">            }
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(</span><span>!</span><span style="color:#eff1f5;">contains1) </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// Mark whether integers 1 to n are in nums
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// Use index as a hash key and negative sign as a presence detector.
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> i </span><span>= </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">; i </span><span>&lt;</span><span style="color:#eff1f5;"> n; i</span><span>++</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> value </span><span>= </span><span style="color:#96b5b4;">abs</span><span style="color:#eff1f5;">(nums[i]);
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(value </span><span>==</span><span style="color:#eff1f5;"> n) {
</span><span style="color:#eff1f5;">                nums[</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">] </span><span>= -</span><span style="color:#96b5b4;">abs</span><span style="color:#eff1f5;">(nums[</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">]);
</span><span style="color:#eff1f5;">            } </span><span style="color:#b48ead;">else </span><span style="color:#eff1f5;">{
</span><span style="color:#eff1f5;">                nums[value] </span><span>= -</span><span style="color:#96b5b4;">abs</span><span style="color:#eff1f5;">(nums[value]);
</span><span style="color:#eff1f5;">            }
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// First positive in nums is smallest missing positive integer
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">for </span><span style="color:#eff1f5;">(</span><span style="color:#b48ead;">int</span><span style="color:#eff1f5;"> i </span><span>= </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">; i </span><span>&lt;</span><span style="color:#eff1f5;"> n; i</span><span>++</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(nums[i] </span><span>&gt; </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">) </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> i;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// nums[0] stores whether n is in nums
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">if </span><span style="color:#eff1f5;">(nums[</span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">] </span><span>&gt; </span><span style="color:#d08770;">0</span><span style="color:#eff1f5;">) {
</span><span style="color:#eff1f5;">            </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> n;
</span><span style="color:#eff1f5;">        }
</span><span style="color:#eff1f5;">
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// If nums contained all elements 1 to n
</span><span style="color:#eff1f5;">        </span><span style="color:#65737e;">// the smallest missing positive number is n + 1
</span><span style="color:#eff1f5;">        </span><span style="color:#b48ead;">return</span><span style="color:#eff1f5;"> n </span><span>+ </span><span style="color:#d08770;">1</span><span style="color:#eff1f5;">;
</span><span style="color:#eff1f5;">    }
</span><span style="color:#eff1f5;">}</span><span>;
</span></code></pre>
<h2 id="rust-solution-borrow-checker-violations-original">Rust Solution: Borrow Checker Violations (Original)</h2>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>impl Solution {
</span><span>    pub fn </span><span style="color:#bf616a;">first_missing_positive</span><span>(mut nums: Vec&lt;i32&gt;) -&gt; </span><span style="color:#bf616a;">i32 </span><span>{
</span><span>        </span><span style="color:#65737e;">// get rid of numbers we don&#39;t care for.
</span><span>        let mut has_one = </span><span style="color:#d08770;">false</span><span>;
</span><span>        </span><span style="color:#b48ead;">for</span><span> num in &amp;mut </span><span style="color:#bf616a;">nums </span><span>{
</span><span>            </span><span style="color:#b48ead;">if </span><span>*num == </span><span style="color:#d08770;">1 </span><span>{
</span><span>                has_one = </span><span style="color:#d08770;">true</span><span>;
</span><span>            }
</span><span>            </span><span style="color:#b48ead;">if </span><span>*num &lt;= </span><span style="color:#d08770;">0 </span><span>|| *num &gt; nums.</span><span style="color:#bf616a;">len</span><span>() as </span><span style="color:#bf616a;">i32 </span><span>{  </span><span style="color:#65737e;">// ❌ BORROW CHECKER ERROR
</span><span>                *num = </span><span style="color:#d08770;">1</span><span>;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>!</span><span style="color:#bf616a;">has_one </span><span>{ </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>; }
</span><span>        </span><span style="color:#b48ead;">for</span><span> num in &amp;</span><span style="color:#bf616a;">nums </span><span>{
</span><span>            let abs_num = num.</span><span style="color:#bf616a;">abs</span><span>();
</span><span>            </span><span style="color:#b48ead;">if</span><span> let </span><span style="color:#bf616a;">Some</span><span>(num_entry) = nums.</span><span style="color:#bf616a;">get_mut</span><span>((abs_num - </span><span style="color:#d08770;">1</span><span>) as usize) {  </span><span style="color:#65737e;">// ❌ BORROW CHECKER ERROR
</span><span>                *num_entry = -</span><span style="color:#d08770;">1 </span><span>* num_entry.</span><span style="color:#bf616a;">abs</span><span>();
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">for</span><span> i in </span><span style="color:#d08770;">0</span><span style="background-color:#bf616a;color:#2b303b;">..</span><span>nums.</span><span style="color:#bf616a;">len</span><span>() {
</span><span>            </span><span style="color:#b48ead;">if</span><span> nums[i] &gt; </span><span style="color:#d08770;">0 </span><span>{
</span><span>                </span><span style="color:#b48ead;">return </span><span>(i + </span><span style="color:#d08770;">1</span><span>) as i32;
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">return </span><span>(nums.</span><span style="color:#bf616a;">len</span><span>() + </span><span style="color:#d08770;">1</span><span>) as i32;
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="borrow-checker-violations-in-rust">Borrow Checker Violations in Rust</h2>
<h3 id="violation-1-mutable-and-immutable-borrow-simultaneously"><strong>Violation 1: Mutable and Immutable Borrow Simultaneously</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">for</span><span> num in &amp;mut </span><span style="color:#bf616a;">nums </span><span>{  </span><span style="color:#65737e;">// Mutable borrow of nums
</span><span>    </span><span style="color:#b48ead;">if </span><span>*num &lt;= </span><span style="color:#d08770;">0 </span><span>|| *num &gt; nums.</span><span style="color:#bf616a;">len</span><span>() as </span><span style="color:#bf616a;">i32 </span><span>{  </span><span style="color:#65737e;">// Immutable borrow of nums
</span><span>        *num = </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p><strong>Error:</strong></p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>error: cannot borrow `nums` as immutable because it is also borrowed as mutable
</span></code></pre>
<p><strong>Why This Happens:</strong></p>
<ul>
<li><code>&amp;mut nums</code> creates a mutable borrow for the entire loop</li>
<li><code>nums.len()</code> tries to create an immutable borrow while mutable borrow is active</li>
</ul>
<h3 id="violation-2-immutable-and-mutable-borrow-simultaneously"><strong>Violation 2: Immutable and Mutable Borrow Simultaneously</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">for</span><span> num in &amp;</span><span style="color:#bf616a;">nums </span><span>{  </span><span style="color:#65737e;">// Immutable borrow of nums
</span><span>    let abs_num = num.</span><span style="color:#bf616a;">abs</span><span>();
</span><span>    </span><span style="color:#b48ead;">if</span><span> let </span><span style="color:#bf616a;">Some</span><span>(num_entry) = nums.</span><span style="color:#bf616a;">get_mut</span><span>((abs_num - </span><span style="color:#d08770;">1</span><span>) as usize) {  </span><span style="color:#65737e;">// Mutable borrow
</span><span>        *num_entry = -</span><span style="color:#d08770;">1 </span><span>* num_entry.</span><span style="color:#bf616a;">abs</span><span>();
</span><span>    }
</span><span>}
</span></code></pre>
<p><strong>Error:</strong></p>
<pre style="background-color:#2b303b;color:#c0c5ce;"><code><span>error: cannot borrow `nums` as mutable because it is also borrowed as immutable
</span></code></pre>
<p><strong>Why This Happens:</strong></p>
<ul>
<li><code>&amp;nums</code> creates an immutable borrow for the entire loop</li>
<li><code>nums.get_mut()</code> tries to create a mutable borrow while immutable borrow is active</li>
</ul>
<h2 id="c-vs-rust-what-c-allows-vs-what-rust-prevents">C++ vs Rust: What C++ Allows vs What Rust Prevents</h2>
<h3 id="1-simultaneous-access-patterns"><strong>1. Simultaneous Access Patterns</strong></h3>
<h4 id="c-unrestricted-access"><strong>C++: Unrestricted Access</strong></h4>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; n; i++) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(nums[i] &lt;= </span><span style="color:#d08770;">0 </span><span>|| nums[i] &gt; n) {  </span><span style="color:#65737e;">// Read access
</span><span>        nums[i] = </span><span style="color:#d08770;">1</span><span>;                      </span><span style="color:#65737e;">// Write access
</span><span>    }
</span><span>}
</span></code></pre>
<p><strong>C++ allows this because:</strong></p>
<ul>
<li>No compile-time safety checks</li>
<li>Manual memory management</li>
<li>Runtime discipline required</li>
<li>Potential for undefined behavior</li>
</ul>
<h4 id="rust-controlled-access"><strong>Rust: Controlled Access</strong></h4>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// This would be unsafe in Rust:
</span><span style="color:#b48ead;">for</span><span> num in &amp;mut </span><span style="color:#bf616a;">nums </span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>*num &lt;= </span><span style="color:#d08770;">0 </span><span>|| *num &gt; nums.</span><span style="color:#bf616a;">len</span><span>() as </span><span style="color:#bf616a;">i32 </span><span>{  </span><span style="color:#65737e;">// Compile error
</span><span>        *num = </span><span style="color:#d08770;">1</span><span>;
</span><span>    }
</span><span>}
</span></code></pre>
<p><strong>Rust prevents this because:</strong></p>
<ul>
<li>Compile-time borrow checking</li>
<li>Prevents data races</li>
<li>Ensures memory safety</li>
<li>Prevents undefined behavior</li>
</ul>
<h3 id="2-iterator-invalidation"><strong>2. Iterator Invalidation</strong></h3>
<h4 id="c-runtime-errors-possible"><strong>C++: Runtime Errors Possible</strong></h4>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>vector&lt;</span><span style="color:#b48ead;">int</span><span>&gt; nums = {</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>};
</span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; nums.</span><span style="color:#bf616a;">size</span><span>(); i++) {
</span><span>    </span><span style="color:#b48ead;">if </span><span>(nums[i] == </span><span style="color:#d08770;">3</span><span>) {
</span><span>        nums.</span><span style="color:#bf616a;">push_back</span><span>(</span><span style="color:#d08770;">6</span><span>);  </span><span style="color:#65737e;">// Modifies vector while iterating
</span><span>        </span><span style="color:#65737e;">// Potential undefined behavior
</span><span>    }
</span><span>}
</span></code></pre>
<h4 id="rust-compile-time-prevention"><strong>Rust: Compile-Time Prevention</strong></h4>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>let mut nums = vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>];
</span><span style="color:#b48ead;">for</span><span> num in &amp;mut </span><span style="color:#bf616a;">nums </span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>*num == </span><span style="color:#d08770;">3 </span><span>{
</span><span>        </span><span style="color:#65737e;">// nums.push(6);  // Compile error: cannot borrow as mutable
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="3-memory-safety"><strong>3. Memory Safety</strong></h3>
<h4 id="c-manual-management"><strong>C++: Manual Management</strong></h4>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">int</span><span>* arr = </span><span style="color:#b48ead;">new int</span><span>[</span><span style="color:#d08770;">10</span><span>];
</span><span style="color:#65737e;">// ... use array ...
</span><span style="color:#b48ead;">delete[]</span><span> arr;  </span><span style="color:#65737e;">// Must remember to free
</span><span style="color:#65737e;">// arr[0] = 5;  // Use after free - undefined behavior
</span></code></pre>
<h4 id="rust-automatic-management"><strong>Rust: Automatic Management</strong></h4>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>let nums = vec![</span><span style="color:#d08770;">1</span><span>, </span><span style="color:#d08770;">2</span><span>, </span><span style="color:#d08770;">3</span><span>, </span><span style="color:#d08770;">4</span><span>, </span><span style="color:#d08770;">5</span><span>];
</span><span style="color:#65737e;">// nums is automatically dropped when it goes out of scope
</span><span style="color:#65737e;">// No possibility of use-after-free
</span></code></pre>
<h2 id="fixed-rust-solution">Fixed Rust Solution</h2>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>impl Solution {
</span><span>    pub fn </span><span style="color:#bf616a;">first_missing_positive</span><span>(mut nums: Vec&lt;i32&gt;) -&gt; </span><span style="color:#bf616a;">i32 </span><span>{
</span><span>        </span><span style="color:#65737e;">// Get length before any borrows to avoid conflicts
</span><span>        let len = nums.</span><span style="color:#bf616a;">len</span><span>() as i32;
</span><span>        
</span><span>        </span><span style="color:#65737e;">// First pass: normalize numbers
</span><span>        let mut has_one = </span><span style="color:#d08770;">false</span><span>;
</span><span>        </span><span style="color:#b48ead;">for</span><span> num in &amp;mut </span><span style="color:#bf616a;">nums </span><span>{
</span><span>            </span><span style="color:#b48ead;">if </span><span>*num == </span><span style="color:#d08770;">1 </span><span>{
</span><span>                has_one = </span><span style="color:#d08770;">true</span><span>;
</span><span>            }
</span><span>            </span><span style="color:#b48ead;">if </span><span>*num &lt;= </span><span style="color:#d08770;">0 </span><span>|| *num &gt; </span><span style="color:#bf616a;">len </span><span>{  </span><span style="color:#65737e;">// Use stored length
</span><span>                *num = </span><span style="color:#d08770;">1</span><span>;
</span><span>            }
</span><span>        }
</span><span>
</span><span>        </span><span style="color:#b48ead;">if </span><span>!</span><span style="color:#bf616a;">has_one </span><span>{ </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">1</span><span>; }
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Second pass: mark numbers as negative using index-based iteration
</span><span>        </span><span style="color:#b48ead;">for</span><span> i in </span><span style="color:#d08770;">0</span><span style="background-color:#bf616a;color:#2b303b;">..</span><span>nums.</span><span style="color:#bf616a;">len</span><span>() {
</span><span>            let abs_num = nums[i].</span><span style="color:#bf616a;">abs</span><span>();
</span><span>            </span><span style="color:#b48ead;">if</span><span> let </span><span style="color:#bf616a;">Some</span><span>(num_entry) = nums.</span><span style="color:#bf616a;">get_mut</span><span>((abs_num - </span><span style="color:#d08770;">1</span><span>) as usize) {
</span><span>                *num_entry = -</span><span style="color:#d08770;">1 </span><span>* num_entry.</span><span style="color:#bf616a;">abs</span><span>();
</span><span>            }
</span><span>        }
</span><span>        
</span><span>        </span><span style="color:#65737e;">// Third pass: find first positive
</span><span>        </span><span style="color:#b48ead;">for</span><span> i in </span><span style="color:#d08770;">0</span><span style="background-color:#bf616a;color:#2b303b;">..</span><span>nums.</span><span style="color:#bf616a;">len</span><span>() {
</span><span>            </span><span style="color:#b48ead;">if</span><span> nums[i] &gt; </span><span style="color:#d08770;">0 </span><span>{
</span><span>                </span><span style="color:#b48ead;">return </span><span>(i + </span><span style="color:#d08770;">1</span><span>) as i32;
</span><span>            }
</span><span>        }
</span><span>        </span><span style="color:#b48ead;">return </span><span>(nums.</span><span style="color:#bf616a;">len</span><span>() + </span><span style="color:#d08770;">1</span><span>) as i32;
</span><span>    }
</span><span>}
</span></code></pre>
<h2 id="key-differences-in-the-fixed-solution">Key Differences in the Fixed Solution</h2>
<h3 id="1-pre-compute-values"><strong>1. Pre-compute Values</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// Before: nums.len() called during mutable borrow
</span><span style="color:#b48ead;">for</span><span> num in &amp;mut </span><span style="color:#bf616a;">nums </span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>*num &gt; nums.</span><span style="color:#bf616a;">len</span><span>() as </span><span style="color:#bf616a;">i32 </span><span>{  </span><span style="color:#65737e;">// Error
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#65737e;">// After: Pre-compute length
</span><span>let len = nums.</span><span style="color:#bf616a;">len</span><span>() as i32;
</span><span style="color:#b48ead;">for</span><span> num in &amp;mut </span><span style="color:#bf616a;">nums </span><span>{
</span><span>    </span><span style="color:#b48ead;">if </span><span>*num &gt; </span><span style="color:#bf616a;">len </span><span>{  </span><span style="color:#65737e;">// Safe
</span><span>    }
</span><span>}
</span></code></pre>
<h3 id="2-index-based-iteration"><strong>2. Index-Based Iteration</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// Before: Immutable borrow conflicts with mutable access
</span><span style="color:#b48ead;">for</span><span> num in &amp;</span><span style="color:#bf616a;">nums </span><span>{
</span><span>    nums.</span><span style="color:#bf616a;">get_mut</span><span>(...);  </span><span style="color:#65737e;">// Error
</span><span>}
</span><span>
</span><span style="color:#65737e;">// After: Index-based iteration, avoid an immutable borrow
</span><span style="color:#65737e;">// in a scope where we need mutable access.
</span><span style="color:#b48ead;">for</span><span> i in </span><span style="color:#d08770;">0</span><span style="background-color:#bf616a;color:#2b303b;">..</span><span>nums.</span><span style="color:#bf616a;">len</span><span>() {
</span><span>    let abs_num = nums[i].</span><span style="color:#bf616a;">abs</span><span>();
</span><span>    nums.</span><span style="color:#bf616a;">get_mut</span><span>(...);  </span><span style="color:#65737e;">// Safe
</span><span>}
</span></code></pre>
<h2 id="performance-comparison">Performance Comparison</h2>
<p><strong>Rust provides the same performance as C++ with additional safety guarantees.</strong></p>
<h3 id="c-performance"><strong>C++ Performance</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// Direct array access - fastest
</span><span style="color:#b48ead;">for </span><span>(</span><span style="color:#b48ead;">int</span><span> i = </span><span style="color:#d08770;">0</span><span>; i &lt; n; i++) {
</span><span>    nums[i] = </span><span style="color:#d08770;">1</span><span>;  </span><span style="color:#65737e;">// Direct memory access
</span><span>}
</span></code></pre>
<h3 id="rust-performance"><strong>Rust Performance</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#65737e;">// Zero-cost abstractions - same performance
</span><span style="color:#b48ead;">for</span><span> num in &amp;mut </span><span style="color:#bf616a;">nums </span><span>{
</span><span>    *num = </span><span style="color:#d08770;">1</span><span>;  </span><span style="color:#65737e;">// Same assembly as C++
</span><span>}
</span></code></pre>
<h2 id="common-rust-patterns-for-this-problem">Common Rust Patterns for This Problem</h2>
<h3 id="1-pre-compute-values-1"><strong>1. Pre-compute Values</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>let len = nums.</span><span style="color:#bf616a;">len</span><span>() as i32;  </span><span style="color:#65737e;">// Avoid borrow conflicts
</span></code></pre>
<h3 id="2-index-based-iteration-1"><strong>2. Index-Based Iteration</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span>
</span><span style="color:#b48ead;">for</span><span> i in </span><span style="color:#d08770;">0</span><span style="background-color:#bf616a;color:#2b303b;">..</span><span>nums.</span><span style="color:#bf616a;">len</span><span>() {  </span><span style="color:#65737e;">// When you need to modify while iterating
</span><span>    </span><span style="color:#65737e;">// Safe to modify nums[i]
</span><span>}
</span></code></pre>
<h3 id="3-use-iter-mut-for-simple-cases"><strong>3. Use <code>iter_mut()</code> for Simple Cases</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">for</span><span> num in &amp;mut </span><span style="color:#bf616a;">nums </span><span>{  </span><span style="color:#65737e;">// When you only need to modify elements
</span><span>    *num = </span><span style="color:#d08770;">1</span><span>;
</span><span>}
</span></code></pre>
<h3 id="4-use-enumerate-for-index-value"><strong>4. Use <code>enumerate()</code> for Index + Value</strong></h3>
<pre data-lang="cpp" style="background-color:#2b303b;color:#c0c5ce;" class="language-cpp "><code class="language-cpp" data-lang="cpp"><span style="color:#b48ead;">for </span><span>(i, num) in nums.</span><span style="color:#bf616a;">iter_mut</span><span>().</span><span style="color:#bf616a;">enumerate</span><span>() {
</span><span>    </span><span style="color:#b48ead;">if </span><span>*num == </span><span style="color:#d08770;">1 </span><span>{
</span><span>        </span><span style="color:#65737e;">// i is the index, num is the value
</span><span>    }
</span><span>}
</span></code></pre>

    </div>

    
        <footer>
            <hr>
            <nav class="post-navigation">
                <a href="https://www.shray.fyi/" class="home-link">&larr; Back to Blog</a>
            </nav>
            <p>
                
                    Published by Aashray Anand
                
                
                
            </p>
            
            
        </footer>
    
</article>



  <!-- optional scripts -->
  
  
  <script src="https://www.shray.fyi/js/codeblock.js"></script>
  

  

  
<script type="text/javascript" src="https://www.shray.fyi/elasticlunr.min.js"></script>
<script type="text/javascript" src="https://www.shray.fyi/js/search.js"></script>


  
</body>

</html>
